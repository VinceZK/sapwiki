#+PAGEID: 1894949410
#+VERSION: 3
#+STARTUP: align
#+TITLE: SDD-Selection
#+OPTIONS: toc:1
** General Information
*** Stakeholders and Roles
| Role                  | Name          |
|-----------------------+---------------|
| Author(s)             | Vincent Zhang |
| Architect             | Vincent Zhang |
| Product Owner         | Shi Ying      |
| Information Developer | Grace Zou     |
| Quality Responsible   | Yao Cen       |
| Developers            |               |

*** References
|                          |                  |             | <30>                           |
| Document Title           | Date             | Link        | Comments                       |
|--------------------------+------------------+-------------+--------------------------------|
| ABAP Persistence Service | <2016-12-16 Fri> | [[https://help.sap.com/saphelp_erp60_sp/helpdata/en/ab/9d0a3ad259cd58e10000000a11402f/frameset.htm][online help]] | Introduce the ABAP persistence services, as well as the transaction service. |

** Context
Selection is used to define filters on potential data sources(HANA Views). During runtime, Selection is applied to SQL select statements to boundary the data for further processing. Selection is a base component in Real-time Consolidation, which is mainly used in RTC Methods. Besides, Selection can also be reused in validation rule and data mapping rules. 

** Design
Selection is model dependent. It needs the CDS view generated by the model, so that a valid sql-where condition can be checked and applied. Details are explained bellow. 

#+Caption: Selection Architecture
[[../image/SelectionArchitecture.png]]

After a model is activated, it generates a bunch of consolidation views, among which only the view with suffix "_U" is picked as the *only default base view* for Selections so far. However, Selections based on the "_U" view indicates it can also be applied on all the views with suffix "_UXX" (_U00, _U10, _U11, _U20, _U21). 

A Selection has one base view and contains one or more selection characteristics, which are derived from the base view, as well as the corresponding DDIC information. The DDIC information is very useful as length check and search help can be derived and reuse.  

#+Caption: Selection UI: Filter Characteristic
[[../image/SelectionUI01.png]]

Once a characteristic is chosen, it grays out to indicate as an already chosen one. Some characteristic are excluded from the available list, as they are non-sense or illegal to be filtering fields. These excluded fields are: MODEL, RTC_CATG, ACCTP, RVERS, PLEVEL, ENTITY, PENTITY, PERIV, KTOPL, RTFLG. 

#+Caption: Selection UI: Filter Expression
[[../image/SelectionUI02.png]]

Filter expression is based on a chosen characteristic, represented as a range. And the string representation is an array like: [from value, to value], value1, value2, ... Currently, the exclude option is not supported. 

#+Caption: Selection UI: Filter Expression Maintain
[[../image/SelectionUI03.png]]

Double click the expression string will popup a dialog allow you to maintain the expression. Multiple "from to" lines can be maintained, and sanity check should be made to check for example: the "from" value should less than the "to" value, different lines should not conflict with each other, and so on. 

To be aware, for boolean values, use "!" as the false. This is because empty value already stands for empty, not the false. 

#+Caption: Selection UI: Filters Overview
[[../image/SelectionUI06.png]]

A Selection can contain multiple filters on different characteristics, which are combined with "AND" operator. For example, in case the Selection has 2 filters: CharA = 'AA' , CharB = 'BB', then they will be interpreted as "CharA = 'AA' and CharB = 'BB'". 

Just like other RTC objects, Selection has 2 states, "SAVED" and "ACTIVE", which may exist simultaneously. When there is "SAVED" copy, the owner of the copy will see the "SAVED" copy by default, while others still see the "ACTIVE" copy.After the owner activate the "SAVED" copy again, the existing "ACTIVE" copy is replaced with "SAVED" copy, and the "SAVED" copy is then deleted.  

Once a Selection is activated, it generates a SQL-Where string. This string is used during DB procedures generation for consolidation tasks. 

#+Caption: SQL-Where String
[[../image/SQLWhereString.png]]

*** 4 Selection Types
There are 4 Selection types to cope with different use cases. 

**** Default Selection
Default Selection is as introduced as above, which is composed by filter expressions. You can define "from to" on each chosen characteristic. 

**** Based on SET
Selection based on SET is used in case there are existing SETs maintained in the ERP, which then can be reused in RTC context. Each characteristic can only be assigned with one SET. And only the SET with the same data element or data domain can be assigned. 

#+Caption: Selection UI: Based on SET
[[../image/SelectionUI04.png]]

**** Free Style 
Free style type allows user to write SQL (only the where conditions) as freely as they can. However, syntax check will be done before the Selection is activated. Free style can cope with situations that default type cannot easily handle. 

*Free Style Selection is not implemented yet.* 

**** Composite Selection
Composite Selection can combine multiple default Selections to compose filter condition connected with "OR" operator. Only Selections with the same base view can be combined in a composite selection. 

#+Caption: Selection UI: Composite Selection
[[../image/SelectionUI05.png]]


*** Table Design

RTC_SELECTION: Selection Head Table
| Field   | isKey | Data Type | Description                |
|---------+-------+-----------+----------------------------|
| MANDT   | X     | CHAR3     | Client                     |
| MODEL   | X     | CHAR6     | Model                      |
| STATE   | X     | CHAR1     | State                      |
| SELNM   | X     | CHAR20    | Selection Name             |
| SELTY   |       | CHAR1     | Selection Type             |
| BVIEW   |       | CHAR30    | Selection Base View        |
| WHSTR   |       | STRING    | Selection SQL Where String |
| CREATOR |       | CHAR12    | Created by                 |
| CTIME   |       | TIMESTAMP | Create timestamp           |
| UPDATOR |       | CHAR12    | Changed by                 |
| UTIME   |       | TIMESTAMP | Change timestamp           |

RTC_SELECTIONT: Selection Text Table
| Field    | isKey | Data Type | Description    |
|----------+-------+-----------+----------------|
| MANDT    | X     | CHAR3     | Client         |
| MODEL    | X     | CHAR6     | Model          |
| STATE    | X     | CHAR1     | State          |
| LANGU    | X     | CHAR1     | Language Key   |
| SELNM    | X     | CHAR20    | Selection Name |
| DESCRIPT |       | CHAR80    | Description    |

RTC_SEL_FLDCOL: Filter Characteristics of a Selection
| Field    | isKey | Data Type | Description                        |
|----------+-------+-----------+------------------------------------|
| MANDT    | X     | CHAR3     | Client                             |
| MODEL    | X     | CHAR6     | Model                              |
| STATE    | X     | CHAR1     | State                              |
| SELNM    | X     | CHAR20    | Selection Name                     |
| FLDNM    | X     | CHAR30    | Filter Characteristic Name         |
| SETCLASS |       | CHAR4     | SET Class                          |
| SUBCLASS |       | CHAR12    | Orgnizational Unit as SET Subclass |
| SETNAME  |       | CHAR24    | SET Name                           |

RTC_SEL_COLF: Characteristic Filter Expression
| Field  | isKey | Data Type | Description                    |
|--------+-------+-----------+--------------------------------|
| MANDT  | X     | CHAR3     | Client                         |
| MODEL  | X     | CHAR6     | Model                          |
| STATE  | X     | CHAR1     | State                          |
| SELNM  | X     | CHAR20    | Selection Name                 |
| FLDNM  | X     | CHAR30    | Filter Characteristic Name     |
| LOW    | X     | CHAR100   | Lower Value                    |
| HIGH   |       | CHAR100   | Higher Value                   |
| SIGN   |       | CHAR1     | Range Sign: Include or Exclude |
| SELOPT |       | CHAR2     | Range Option                   |

RTC_SEL_SGLSEL: Single Selection in a Composite Selection
| Field  | isKey | Data Type | Description           |
|--------+-------+-----------+-----------------------|
| MANDT  | X     | CHAR3     | Client                |
| MODEL  | X     | CHAR6     | Model                 |
| STATE  | X     | CHAR1     | State                 |
| SELNM  | X     | CHAR20    | Selection Name        |
| SGLSEL | X     | CHAR20    | Single Selection Name |


*** Life Cycle Management
Selection is designed as an embedded component, which is mainly re-used in RTC Method. 

#+Caption: Selection in CT Method
[[../image/SelectionInMethod.png]]

Selection created in Tcode "RTCSEL" are called "Reusable Selection". But usually, user can maintain Selection directly in Method, which are called "Embedded Selection". 

Embedded Selections are managed along with the Method holds them. If a Method is failed to be activated (due to some reason like incorrect configurations), then, Embedded Selections are also persisted in the "SAVED" copy. Embedded Selections are under the namespace with prefix "$". They are not re-usable, and cannot be created/changed/deleted using RTCSEL(display is possible).

Reusable Selections are maintained in Tcode "RTCSEL", and can be reused in RTC Methods. You can not change a Reusable Selection in a Method, but only change it in "RTCSEL". Once a Reusable Selection is changed, it gets all the Methods that the Selection is used, and ask for re-activation of those Methods.

Above activation chain mechanism is not realized yet. This is mainly due to the transportation feature is still under construction. If you make a change of a Selection in DEV system, then you transport it to PROD system. Although the ACTIVE copy of Selection is imported to the PROD system, however, those Methods which use it won't be re-activated automatically. The conventional way is to define AIM(After Import Method) in SOBJ, which can trigger the re-activation logic after Selection is imported. However, AIM is forbidden now due to ZDM, details can be found in note [[https://launchpad.support.sap.com/#/notes/1429180][1429180]] and [[https://wiki.wdf.sap.corp/wiki/display/LMCROSS/ZDM+Development+Guidelines][ZDM Development Guidelines]]. 

Thus, we need to think about triggering the re-activation during the productive use of the application. We can provide 2 possible solutions:
1. An ABAP report, which is manually executed after each import.
2. Embedded activation logic in all end-user APPs. During runtime, it checks whether re-activation is necessary. If yes, re-activate then run. 

Both solutions need a smart way to check what's the dependency, and only activate the objects affected to save runtime. In other words, we need a robust version system to version all the RTC objects. 


** Program Detail
#+Caption: Selection Program Building Block
[[../image/SelectionProgramBlock.png]]

Selection is designed under the pattern MVVM(Model, View, and View Model). 

*** Model Layer
The model layer is utilized using ABAP persistent classes, which are auto-generated based on DDIC tables/views. The ABAP persistent class is leveraged as we use an OO pattern to support the component level reusibility. 

Each table has its own persistent class, and we have 5 persistent classes.
| Table          | Persistent Class     |
|----------------+----------------------|
| RTC_SELECTION  | CL_RTC_PS_SELECTION  |
| RTC_SELECTIONT | CL_RTC_PS_SELECTIONT |
| RTC_SEL_FLDCOL | CL_RTC_PS_SEL_FLDCOL |
| RTC_SEL_COLF   | CL_RTC_PS_SEL_COLF   |
| RTC_SEL_SGLSEL | CL_RTC_PS_SEL_SGLSEL |

There is no business logic in the persistent classes, except one special method. The method CL_RTC_PS_SELECTION->GET_BVIEW is adjusted with following logic:
#+CAPTION: CL_RTC_PS_SELECTION->GET_BVIEW
#+BEGIN_SRC abap
  method get_bview.
    state_read_access.

    if bview+0(8) = '/RTCART/'.
      bview+8(3) = sy-mandt.
    endif.

    result = bview.
  endmethod.
#+END_SRC
This is due to the RTC Model generated views are client-dependent, which contains client number in their names(like: /RTCART/100VINCE1_U). And if you transport a Selection from DEV client 100 to a PRD client 200, then the base view name should be adjusted to the right client(like: /RTCART/200VINCE1_U). 

*** Model Controller(aka Interaction Layer)
Interaction layer class(CL_RTC_IL_SELECTION) is built upon persistent classes. It acts as a model controller to combine tables into a business object, and connects to UI level operations. Following main methods are implemented in this layer:
| Method                | Description                                     |
|-----------------------+-------------------------------------------------|
| CREATE_SELECTION      | Create a Selection persistent object            |
| ADD_SELECT_OPTION     | Add a select option for a column                |
| DELETE_SELECTION_H    | Delete a selection header persistent object     |
| GET_SELECTION         | Get a selection first by S, then A.             |
| CHANGE_SELECTION      | Change current selection                        |
| ACTIVE_SELECTION      | Active current selection                        |
| COPY_CREATE_SELECTION | Copy create a selection from a source selection |
| SAVE                  | Save all changes                                |
| UNDO                  | Undo all changes                                |
#+CAPTION: CL_RTC_IL_SELECTION->CREATE_SELECTION
#+BEGIN_SRC abap
  method get_bview.
    enqueue_selection( iv_model = model iv_selnm = selnm ).

    try.

        selection =
        ca_rtc_ps_selection=>agent->create_persistent(
            i_model = model
            i_selnm = selnm
            i_state = iv_state
        ).

        ro_selection = selection.

      catch cx_os_object_existing.
        raise exception type cx_rtc_comm_il_01.
    endtry
  endmethod.
#+END_SRC
In the methods, it calls persistent classes, and raise exceptions to UI.

*** View 
The view layer here stands for the ALV GRID. In general, Selection is composed with 3 ALV Grids:

| Grid Instance  | Description                                                        |
|----------------+--------------------------------------------------------------------|
| MO_COL_GRID    | The Overview grid to display filter columns and expressions        |
| MO_SELOPT_GRID | The grid is used to maintain filters(from, to) for a single column |
| MO_SGLSEL_GRID | The grid is used in composite  Selection to list single Selections |

This layer mainly contain logic to initialize and operate ALV Grids. 
| Method                   | Description                   |
|--------------------------+-------------------------------|
| CREATE_COL_GRID          | Create a column grid instance |
| REGISTER_COL_GRID_EVENTS | Register ALV grid events      |
| BUILD_COL_GRID_FLDCAT    | Build grid field category     |
|                          |                               |

*** View Model(aka Component Layer)
The view model operates on the interaction layer to provide multiple instances on the same UI. For example, one CT Method can have multiple Selections. These Selections would be handled as a single unit. The component layer provides the isolation, it has attributes to store the transient data for the UI display, and synchronize the changes between UI and IL. Besides, it has similar method structure as the IL class. 

*** RTCSEL
RTCSEL(Function Group: RTC_SELECTION) is the general Selection maintenance transaction. It is in standard GUI Dynpro which is built upon CL_RTC_CP_SELECTION and CL_RTC_GRID_SELECTION. There is no additional business logic in RTCSEL, except the Dynpro flow. It also acts as an example on how to embed Selection component into other applications. 

