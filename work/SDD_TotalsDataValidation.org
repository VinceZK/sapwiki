#+PAGEID: 1828633219
#+VERSION: 5
#+STARTUP: align
#+OPTIONS: toc:1
#+TITLE: SDD-Totals Validation
** Context
Totals data includes: 
1. *Reported financial data*
2. *Standardized financial data*  
3. *Consolidated data*
4. *Additional financial data* 

Totals data validation uses validation rules, which you can define in Customizing. To do this, you establish selection conditions (usually with items and sub-items), which you then use in a formula. Then the system tests whether the validation rule is true orX1 false for a given data set. 

We will leverage HRF to realize the totals data validation. As HRF has a fancy rule editor and generates DB procedures to encapsulate rule logic. In our first release, we will re-use the HRF@BRF workbench as the rule maintenance UI, and provide an ABAP report to consume the generated HANA artifacts. Later on, we will consider how to integrate HRF's UI control into our rule maintenance APP, and establish a deep integration with BPC's control framework. 

*** Some examples for totals validations
+ Total assets = total liabilities
+ Net profit = appropriation of retained earnings
+ Retained earnings on balance sheet = annual net income on income statement

 
** Use Case Description

*** Persona
*IT Professional*: Create initial rule contexts, DB modeling, and deliver example rules. Knowledge transfer to accountants so that they can maintain rules by themselves. 

*Local Accountant*: Do validations on his own reported financial data based on the rules defined by group accountant. He can also define his local rules if possible.

*Group Accountant*: Do validations on all subsidiaries' reported financial data. She defines group rules which should be applied to all subsidiaries (Each subsidiary could be assigned with different rules). She also validates the standardized financial data and the consolidated data.

*** Data Flow and Validations Point (runtime)
Data validation in RTC usually contains =Document Validation= and =Totals Validation=. =Document Validation= happens on every incoming financial document. It does validation on the transient data that supplied with middle-ware(Real-time Journal Replication) or UI(Manually Input). This SDD mainly presents  =Totals Validation= in RTC. 

=Totals Validation= does data aggregations and comparisons on the persisted data mainly in ACDOCA and ACDOCC. User could also have additional data to be involved in the validation calculation. Following diagram describes details.

#+CAPTION: Validation in RTC
[[../image/ValidationEngineContext.png]]  

=Reported Financial Data= mainly resides in ACDOCA as in Central Finance case, we already have local financial data be replicated real-timely. The local data is then read and validated. Only if the validation is passed, the aggregated reported financial data can be saved in in ACDOCC. It is also possible the local data is coming from flexible uploading (through spreadsheet), then the data is not persisted. In this case, we could let the data be saved in ACDOCC first with a special status to indicate that it is not validated. After the successfully validation, the status is changed to "Validated".

When financial data is reported (with "Validated" status in ACDOCC), we can run standardizing and currency translation tasks. The result is upserted into ACDOCC which forms a standardized data set. We run validation on the =Standardized Financial Data= to check certain rules is fulfilled. 

BPC will then do eliminations and consolidations on the standardized financial data. The result is again write-back to ACDOCC. Then we have the final consolidation result set which can be used for different Corp level financial statements. But before the disclosure, we should run =Consolidated Data= validation again to make sure the result is correct. If error or inconsistency is found, you can adjust it through manual posting.   
 
*** Rule Authoring Process (design time)
There should be an easy use tool to allow accountants define their rules intuitively. This tool is Firoi-based and close to accountants context. But it won't be showed in the first release as to deliver a Fiori APP needs lots of gates to go through. We decide to leverage the BRF workbench as an temporal solution to let accountants maintain their rules. 

Thus the following work-flow for rule design time is presented. 
 
#+CAPTION: Validation Engine in RTC
[[../image/VE_RuleDefination.png]]  

At first, IT professionals need to do rule context definition. That's mainly regarding with CDS views creation to form a rule context. The CDS views are mainly based on ACDOCA and ACDOCC with associations to master data dimension tables. Each CDS view is assigned to a BRF application in the web workbench. 

Group accountants can define their own rules based on the sample rules that IT professionals created. She can group rules into rule sets which can then be assigned to each consolidation group/unit. Local accountants can define their own rules too, but only effect on his own consolidation unit. Both of them use a same Tcode to run validation on different aspects.  


** Design
We will re-use the BRF workbench as the rule maintenance UI. We won't develop an additional UI for end-users to defines rules, but only deliver 3 BRF+ applications which stand for "Reported Financial Data", "Standardized Financial Data", and "Consolidated Data" respectively. Each BRF+ application contains multiple functions which share a same data context(data objects). Data objects are generated from CDS views. The associations in a CDS view can be now interpreted by BRF+. So we can use CDS to define the validation data contexts.

We will then define 3 CDS views respectively for the 3 totals validation types:
1. Reported financial data: Unions of ACDOCA and ACDOCC.
2. Standardized data: on ACDOCC.
3. Consolidated data: on ACDOCC.

The following diagram describes detail:
#+CAPTION: Totals Validation Class Diagram
[[../image/TotalsValidation.png]]  

Validation type defines the data context and output. It is the super class that our 3 totals validation types are inherited on. 

A validation step contains "Prerequisite", "Check", and "Output". "Prerequisite" could be a simple expression, or another validation step. "Check" is the actual expression that represents the main validation rule logic. "Output" defines the validation result output structure, it could be an ABAP message structure with additional variables.   

A validation type and its multiple validation steps forms an actual "Validation". A "Validation" can be assigned to Consolidation groups and units. According to different validation types, "Reported Data Validation" and "Standardized Validation" can only be assigned to consolidation units; While "Consolidated Validation" could only be assigned to consolidation groups. 

From technique point of view, a "Validation Type" and its "Validation Steps" can be represented using a BRF+ application with multiple functions. To be simplifying, we can only have 3 validations in the first release, all consolidation groups and units just share the same validation.

*** Table Design
"Validation Type", "Validation Step", and "Validation" should be persisted. Following tables design are given:

#+CAPTION: Validation Type
| Field    | Key | Description      |
|----------+-----+------------------|
| MANDT    | X   | SAP Client       |
| VTYPE    | X   | Validation Type  |
| BRF_APP  |     | BRF+ Application |
| DESCRIPT |     | Description      |
 
A validation type maps to a BRF+ application. We will predefine 3 validation types and their respective BRF+ application: "Reported Financial Data Validation", "Standardized Validation", and "Consolidated Validation". As CDS views are already assigned to the BRF+ application, so it is not necessary to assign here again.

#+CAPTION: Validation Step
| Field    | Key | Description                     |
|----------+-----+---------------------------------|
| MANDT    | X   | SAP Client                      |
| VTYPE    | X   | Validation Type                 |
| VSTEP    | X   | Validation Step Name            |
| PREREQ   |     | Prerequisite of the Step        |
| FUNC     |     | BRF+ Function of an Application |
| OUTPUT   |     | Output Structure Name           |
| DESCRIPT |     | Description                     |

A validation step maps to a BRF+ function in the corresponding application(validation type). As a step could have its prerequisite which could be another step, you can maintain another function name in the field "PREREQ". A BRF+ function has its output structure, so it may not be necessary to assign a "OUTPUT" structure for a validation step again. We here reserve the "OUTPUT" field for future use. 

#+CAPTION: Validation Head
| Field    | Key | Description                |
|----------+-----+----------------------------|
| MANDT    | X   | SAP Client                 |
| VNAME    | X   | Validation Name            |
| VTYPE    |     | Validation Type            |
| BRFFUNC  |     | Execute all BRF+ functions |
| DESCRIPT |     | Description                |

You define an actual "Validation" based on a "Validation Type". You can then choose and import the steps(functions) that belong to the validation type. The steps will be persisted in the "validation steps table" bellow.  If "BRFFUNC" is checked, then it will discard the contents in the validation steps table, and execute all the functions belong to the BRF+ application. It will be much easier that you only define functions in BRF+ application, without assigning them in those customization tables again.  

#+CAPTION: Validation Steps
| Field    | Key | Description        |
|----------+-----+--------------------|
| MANDT    | X   | SAP Client         |
| VNAME    | X   | Validation Name    |
| VSTEP    | X   | Validation Step    |
| SEQUENCE |     | Execution Sequence |

Validation steps table persists steps that are chosen for this validation. It has an additional "SEQUENCE" field to control the execution sequence during runtime.   

*** Design Time Flow
We predefine 3 BRF+ applications(Including CDS Views), and their corresponding objects(Validation Type and Validation) in RTC. End-users only need to define functions under each BRF+ application. The functions must be copied from an example one, and should be based on the same data objects and output definition. Rules can be redefined by users' own needs. It is still possible to enhance the data objects or even redefine the BRF+ application to fulfill further requirements. 

All the activities above are actually based on standard HRF@BRF+ features. RTC can then cascade the definitions in BRF+ into its own context by defining mappings, and run the generated BRF+ artifacts. No additional efforts are needed at the design time.  

*** Run Time Flow
The detail run time data and calling flow need further investigation during development. The mockup UIs for triggering the run of validation are given.

#+CAPTION: Totals Data Validation Initial Screen
[[../image/TotalsValidationUI_01.png]]  

You must choose a RTC model, a consolidation version, and Fiscal Year/Period for a totals validation run. You can narrow the validation by assigning specific consolidation groups and units. Each time you can run one type of validation by choosing a radio button. The "Display Log" check-box controls whether details logs should be given or only a signal result "Pass/Error" will be given.  

#+CAPTION: Totals Data Validation Results Screen
[[../image/TotalsValidationUI_02.png]]  

The result screen is splitted into 2 areas. It is built using BAL framework. ~Refer demo ABAP program: SBAL_DEMO_05_E~

The left area of the result view shows the consolidation hierarchy. The hierarchy is maintained in BPC, which can be gotten using a specific BPC interface. The traffic lights are grouped by status of each children nodes. If one child node has an error result, then all its parent groups have the "red" light. Click each node will show all validation results that belong to it. A "Group" node will contain all its "Unit" results combined with its own validation results. 

The right area displays a list of validation results that belong to the node you selected. First column is the traffic light of each rule(validation step/BRF function) result. Second column is the rule text(step/function description). You click the detail information to pop-up a dialog to show detail rule context information, like: the rule outputs, long description, variables in runtime, and so on.


** HRF@BRF
*** Pre-Delivered Content
Application, functions, data objects and underlying CDS views

*** Examples of RTC rules in HRF
**** Check cost center based on a line item in ACDOCC

=Prerequisite=:
If company code = "F001" and account = "1001010" (expense)

=Check=:
Cost center is in a range between "xxxx" and "xxxx".

*Realization:*

Actual Rule in HRF Decision Table (Rule Name: DocumentPosting): 
| CompanyCode | GroupAccount | CostCenter                                   | Output |
|-------------+--------------+----------------------------------------------+--------|
| 'F001'      | '0003051090' | is not between 'SFUT000200' and 'SFUT000243' | 'E'    |
|             |              |                                              | 'S'    |

*Test Cases:*
| Expectation | CCode | Group Account |    Doc No. | Item No. | Cost Center |
|-------------+-------+---------------+------------+----------+-------------|
| should fail | F001  |    0003051090 | 1900004211 |   000002 | 0000001101  |
| should pass | F001  |    0003051090 | 0100009825 |   000002 | SFUT000243  |
| should pass | F001  |    0003051090 | 0100009821 |   000002 | SFUT000242  |
| Should pass | F001  |    0003082090 | 1900004205 |   000006 | 0000001102  |

**** Actual vs Plan: ACDOCC/ACDOCA/COEP
~ERP is realized using User Exit~

=Prerequisite=:
If controlling area = "0001" and account type = "expense", 

=Check=:
1. Sum (planned amount of COEP) where account type = "expense" and cost center = "c001" and current period = "2015001" as "planned"
2. Sum (actual amount of ACDOCA) where account type = "expense" and cost center = "c001" and current period = "2015001" as "actual".
3. If (actual > planned), then give error message.

*Issues*:

1. HRF service can only do filtering on one data object. If you assign filter conditions on 2 different data objects, the reuslt will be the Cartesian product of result of 2 data object. It is a usual requirement that you sum amounts of table A, and compare this value to the sum of amounts of table B, while Table A and Table B can not be joined together. 

   The workaround solution for this kind of scenarios is to use CDS view to union actual and planned amounts. Then add this union-ed CDS view to HRF Vocabulary as a data object, and join it to the main data object. 

2. There is performance issue when comparing two sumerize values. Need further investigation.

3. ~Prerequisite~ realized using Decision Table is not performance good. It is worth to consider using to rule services. First check prerequisite rule service, if passed, then check the actual rules.

*Realization:*

1. Create a CDS view on ACDOCA to summarize actual values happened.
   CDS View: I_Acdoca_Rtc_Tst
2. Create a CDS view on COEP to summarize planned values happened.
   CDS View: I_Coep_Rtc_Tst
3. Create a CDS view unions above 2.
   CDS View: I_Actual_Plan_RTC_TST
4. Add I_Actual_Plan_RTC_TST to HRF vocabulary.
   Vocabulary: tmp.fi.rtc.hrf.ZTEST.HRFTest::posting
5. There should be an ACDOCA-like data object to accept input line-items from internal table. Here I just use ACDOCA to simulate. But there is a drawback that you just can not add the current value to happened value to get a simulation.
6. Join ACDOCA to I_Actual_Plan_RTC_TST.
7. Create a rule ~Posting_ActualvsPlan~ and rule service ~DocumentPosting02~:

| Prerequisite | Actual Value | Outputs |
|--------------+--------------+---------|
| false        |              | 'S'     |
| true         | < PlanValue  | 'S'     |
| true         |              | 'E'     |

Where 3 alias are defined like this:
1. ~Prerequisite~: CtrlArea of the ACDOCA = '0001' and Account of the ACDOCA = '0000476000'
2. ~ActualValue~: sum of AMOUNT of all ActualPlans of an ACDOCA where VERSION = '000'
3. ~PlanValue~: sum of AMOUNT of all ActualPlans of an ACDOCA where VERSION = '100'

*Test Cases:*
| Expectation |    Doc No. | Item No. |    Account | CostCenter | Period |            Actual |           Planned |
|-------------+------------+----------+------------+------------+--------+-------------------+-------------------|
| should pass | 0100027332 |   000001 | 0000476000 | CC01       |    010 |              -127 |               -13 |
| should fail | 0100036001 |   000002 | 0000476000 | CC02       |    004 |               132 |              NULL |
| should fail | 0100000702 |   000001 | 0000476000 | CC100      |    006 |               200 |               100 |
| should fail | 0100000352 |   000002 | 0000476000 | CC200      |    005 | 112,345,679,135.1 | 112,345,679,135.1 |
| should pass | 0100001835 |   000002 | 0000400000 | CC200      |    007 |            144.48 |             44.48 |

#+CAPTION: Check Actual and Planned amount 
#+BEGIN_SRC sql 
  select * from SAPER9.Z_ACTPLAN_RTC
           WHERE CostCenter = 'CC200'
           and CtrlArea = '0001'
           and Account = '0000476000'
           and FiscalYear = '2015'
           and Period = '005'
           -- and Period = '010'
#+END_SRC

#+CAPTION: Find corresponding FI documents 
#+BEGIN_SRC sql 
select 
"BELNR",
"DOCLN",
"RACCT",
"RCNTR",
"RHCUR",
"FISCYEARPER",
"HSL"
 from "SAPER9"."ACDOCA"
 WHERE RCLNT = '500'
   AND RLDNR = '0L'
   AND KOKRS = '0001'
   AND RCNTR = 'CC200'
   --AND RCNTR = 'CC01'
   AND RACCT = '0000476000'
   --AND RACCT = '0000400000'
   AND FISCYEARPER = '2015005'
#+END_SRC

#+CAPTION: Run HRF procedure in SQL console and get SQL Plan graph 
#+BEGIN_SRC sql
SELECT * FROM "SAP_HRF"."tmp.fi.rtc.hrf.service::DocumentPosting02.VIEW" 
('PLACEHOLDER' = ('$$DocNum$$', '0100027332'), 'PLACEHOLDER' = ('$$ItemNum$$', '000001'))
#+END_SRC

*** User exists (rules)
*** RTC and BRF integration
**** Design time
